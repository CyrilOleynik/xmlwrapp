<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>xmlwrapp: xml::node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xmlwrapp
   </div>
   <div id="projectbrief">Lightweight C++ XML parsing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexml.html">xml</a></li><li class="navelem"><a class="el" href="classxml_1_1node.html">node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classxml_1_1node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xml::node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> class is used to hold information about one XML node.  
 <a href="classxml_1_1node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8h_source.html">node.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1cdata.html">cdata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> of type_cdata.  <a href="structxml_1_1node_1_1cdata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1comment.html">comment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> of type_comment.  <a href="structxml_1_1node_1_1comment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">xml::node::const_iterator</a> provides a way to access children nodes similar to a standard C++ container.  <a href="classxml_1_1node_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> provides a way to access children nodes similar to a standard C++ container.  <a href="classxml_1_1node_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1pi.html">pi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> of type_pi.  <a href="structxml_1_1node_1_1pi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1text.html">text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> of type_text.  <a href="structxml_1_1node_1_1text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a940647610d4ab69275a4889886b3cc73"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">node_type</a> { <br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442">type_element</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73ad3894a3c892717b03c8835774bade863">type_text</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73ad08a3d7542cb53715b7eb9fe61afc43a">type_cdata</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73af9787bf54e2a8186b643aaabf94850ad">type_pi</a>, 
<br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73aba376b6f894af123d9b0d2d3e9a87754">type_comment</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73aeaad8ffd4e23a12dc244b10502c3630a">type_entity</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73af09519f20be672ab7271f9588cb1f141">type_entity_ref</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a47e2014a31a4e8d5ce5b65610be5785a">type_xinclude</a>, 
<br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a90fb6fc3b406e9eabc666307a2182505">type_document</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a5ad2575daf153e4c9342098834e800b1">type_document_type</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a510868f4ada4c9e121907f2926253dc9">type_document_frag</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a4b4ec4e4ae3cd25413af91024e3d5c7d">type_notation</a>, 
<br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73ad067513260fc3cba8adb7e4046fa522f">type_dtd</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a71a97e98535c1961a23a781758921fec">type_dtd_element</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73affbc2f67724bd953ca2cc4fb5f788668">type_dtd_attribute</a>, 
<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73acd5165d4b1015313b836696388511e04">type_dtd_entity</a>, 
<br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a22cffeab9645fd51d6341a7e6ef8de91">type_dtd_namespace</a>
<br />
 }</td></tr>
<tr class="memdesc:a940647610d4ab69275a4889886b3cc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for the different types of XML nodes  <a href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">More...</a><br /></td></tr>
<tr class="separator:a940647610d4ab69275a4889886b3cc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc984683e587a1cdc89b06930ab8cfee"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#acc984683e587a1cdc89b06930ab8cfee">size_type</a></td></tr>
<tr class="memdesc:acc984683e587a1cdc89b06930ab8cfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type  <a href="#acc984683e587a1cdc89b06930ab8cfee">More...</a><br /></td></tr>
<tr class="separator:acc984683e587a1cdc89b06930ab8cfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36262413721060030db06031e6932233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a36262413721060030db06031e6932233">node</a> ()</td></tr>
<tr class="memdesc:a36262413721060030db06031e6932233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new blank <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>.  <a href="#a36262413721060030db06031e6932233">More...</a><br /></td></tr>
<tr class="separator:a36262413721060030db06031e6932233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e68e8305a47f686b22a2b39f60c5cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a53e68e8305a47f686b22a2b39f60c5cb">node</a> (const char *name)</td></tr>
<tr class="memdesc:a53e68e8305a47f686b22a2b39f60c5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> and set the name of the node.  <a href="#a53e68e8305a47f686b22a2b39f60c5cb">More...</a><br /></td></tr>
<tr class="separator:a53e68e8305a47f686b22a2b39f60c5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfe3254a9552e9d398053c67bea42de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a5cfe3254a9552e9d398053c67bea42de">node</a> (const char *name, const char *content)</td></tr>
<tr class="memdesc:a5cfe3254a9552e9d398053c67bea42de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> given a name and content.  <a href="#a5cfe3254a9552e9d398053c67bea42de">More...</a><br /></td></tr>
<tr class="separator:a5cfe3254a9552e9d398053c67bea42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc8f567fa1ec7ced116ed4fc2cd0c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#addc8f567fa1ec7ced116ed4fc2cd0c4d">node</a> (<a class="el" href="structxml_1_1node_1_1cdata.html">cdata</a> cdata_info)</td></tr>
<tr class="memdesc:addc8f567fa1ec7ced116ed4fc2cd0c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_cdata.  <a href="#addc8f567fa1ec7ced116ed4fc2cd0c4d">More...</a><br /></td></tr>
<tr class="separator:addc8f567fa1ec7ced116ed4fc2cd0c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cf010b25c9f0ea2415ae99c6610bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aac5cf010b25c9f0ea2415ae99c6610bc">node</a> (<a class="el" href="structxml_1_1node_1_1comment.html">comment</a> comment_info)</td></tr>
<tr class="memdesc:aac5cf010b25c9f0ea2415ae99c6610bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_comment.  <a href="#aac5cf010b25c9f0ea2415ae99c6610bc">More...</a><br /></td></tr>
<tr class="separator:aac5cf010b25c9f0ea2415ae99c6610bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1a164e7c81012e4a721531c34d6ba5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aad1a164e7c81012e4a721531c34d6ba5">node</a> (<a class="el" href="structxml_1_1node_1_1pi.html">pi</a> pi_info)</td></tr>
<tr class="memdesc:aad1a164e7c81012e4a721531c34d6ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_pi.  <a href="#aad1a164e7c81012e4a721531c34d6ba5">More...</a><br /></td></tr>
<tr class="separator:aad1a164e7c81012e4a721531c34d6ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2aa7ee2a4fee030e7c9bb0f64db859"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aaf2aa7ee2a4fee030e7c9bb0f64db859">node</a> (<a class="el" href="structxml_1_1node_1_1text.html">text</a> text_info)</td></tr>
<tr class="memdesc:aaf2aa7ee2a4fee030e7c9bb0f64db859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_text.  <a href="#aaf2aa7ee2a4fee030e7c9bb0f64db859">More...</a><br /></td></tr>
<tr class="separator:aaf2aa7ee2a4fee030e7c9bb0f64db859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a362154201ae3c6aa4213d4c8319e05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a7a362154201ae3c6aa4213d4c8319e05">node</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;other)</td></tr>
<tr class="memdesc:a7a362154201ae3c6aa4213d4c8319e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> by copying another <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>.  <a href="#a7a362154201ae3c6aa4213d4c8319e05">More...</a><br /></td></tr>
<tr class="separator:a7a362154201ae3c6aa4213d4c8319e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea95ca4cd8eb9a27dc5f51dd61c0987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a5ea95ca4cd8eb9a27dc5f51dd61c0987">operator=</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;other)</td></tr>
<tr class="memdesc:a5ea95ca4cd8eb9a27dc5f51dd61c0987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this node equal to some other node via assignment.  <a href="#a5ea95ca4cd8eb9a27dc5f51dd61c0987">More...</a><br /></td></tr>
<tr class="separator:a5ea95ca4cd8eb9a27dc5f51dd61c0987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cfd0d55c969e9407d09b56fe6d4fd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae6cfd0d55c969e9407d09b56fe6d4fd9">~node</a> ()</td></tr>
<tr class="memdesc:ae6cfd0d55c969e9407d09b56fe6d4fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor.  <a href="#ae6cfd0d55c969e9407d09b56fe6d4fd9">More...</a><br /></td></tr>
<tr class="separator:ae6cfd0d55c969e9407d09b56fe6d4fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d75545214dba0cf6d7efeb5ecfa2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a02d75545214dba0cf6d7efeb5ecfa2bc">set_name</a> (const char *name)</td></tr>
<tr class="memdesc:a02d75545214dba0cf6d7efeb5ecfa2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>.  <a href="#a02d75545214dba0cf6d7efeb5ecfa2bc">More...</a><br /></td></tr>
<tr class="separator:a02d75545214dba0cf6d7efeb5ecfa2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0cf220ca2986163e623596dea5318b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aca0cf220ca2986163e623596dea5318b">get_name</a> () const </td></tr>
<tr class="memdesc:aca0cf220ca2986163e623596dea5318b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>.  <a href="#aca0cf220ca2986163e623596dea5318b">More...</a><br /></td></tr>
<tr class="separator:aca0cf220ca2986163e623596dea5318b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4625509cfbe6bf475f751d51ff6f10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a">set_content</a> (const char *content)</td></tr>
<tr class="memdesc:ab4625509cfbe6bf475f751d51ff6f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the content of a node.  <a href="#ab4625509cfbe6bf475f751d51ff6f10a">More...</a><br /></td></tr>
<tr class="separator:ab4625509cfbe6bf475f751d51ff6f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e81da5ef8eed970e974d1945c4d830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af7e81da5ef8eed970e974d1945c4d830">set_text_content</a> (const char *content)</td></tr>
<tr class="memdesc:af7e81da5ef8eed970e974d1945c4d830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the content of a node to given text.  <a href="#af7e81da5ef8eed970e974d1945c4d830">More...</a><br /></td></tr>
<tr class="separator:af7e81da5ef8eed970e974d1945c4d830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072e7b9d99a9bcedaed6f139036e36c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ac072e7b9d99a9bcedaed6f139036e36c">get_content</a> () const </td></tr>
<tr class="memdesc:ac072e7b9d99a9bcedaed6f139036e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content for this text node.  <a href="#ac072e7b9d99a9bcedaed6f139036e36c">More...</a><br /></td></tr>
<tr class="separator:ac072e7b9d99a9bcedaed6f139036e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b944576d7a197d20eaf4d9a2fa91422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a2b944576d7a197d20eaf4d9a2fa91422">get_type</a> () const </td></tr>
<tr class="memdesc:a2b944576d7a197d20eaf4d9a2fa91422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this node's "type".  <a href="#a2b944576d7a197d20eaf4d9a2fa91422">More...</a><br /></td></tr>
<tr class="separator:a2b944576d7a197d20eaf4d9a2fa91422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc02a04956784efa60a740a165b464b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1attributes.html">xml::attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#adfc02a04956784efa60a740a165b464b">get_attributes</a> ()</td></tr>
<tr class="memdesc:adfc02a04956784efa60a740a165b464b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of attributes.  <a href="#adfc02a04956784efa60a740a165b464b">More...</a><br /></td></tr>
<tr class="separator:adfc02a04956784efa60a740a165b464b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4feeba192f50d0b0f34de3ff861941"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxml_1_1attributes.html">xml::attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aca4feeba192f50d0b0f34de3ff861941">get_attributes</a> () const </td></tr>
<tr class="memdesc:aca4feeba192f50d0b0f34de3ff861941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of attributes.  <a href="#aca4feeba192f50d0b0f34de3ff861941">More...</a><br /></td></tr>
<tr class="separator:aca4feeba192f50d0b0f34de3ff861941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae460b5749a0efd275b4999ff33910dbc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae460b5749a0efd275b4999ff33910dbc">get_namespace</a> () const </td></tr>
<tr class="memdesc:ae460b5749a0efd275b4999ff33910dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>.  <a href="#ae460b5749a0efd275b4999ff33910dbc">More...</a><br /></td></tr>
<tr class="separator:ae460b5749a0efd275b4999ff33910dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab847851d49148c231bd6630ee1b7e9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab847851d49148c231bd6630ee1b7e9b3">set_namespace</a> (const std::string &amp;href)</td></tr>
<tr class="memdesc:ab847851d49148c231bd6630ee1b7e9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>.  <a href="#ab847851d49148c231bd6630ee1b7e9b3">More...</a><br /></td></tr>
<tr class="separator:ab847851d49148c231bd6630ee1b7e9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4ec63c7b08c440fd3520cdaecf57a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#abf4ec63c7b08c440fd3520cdaecf57a9">is_text</a> () const </td></tr>
<tr class="memdesc:abf4ec63c7b08c440fd3520cdaecf57a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if this node is a text node or something like a text node, CDATA for example.  <a href="#abf4ec63c7b08c440fd3520cdaecf57a9">More...</a><br /></td></tr>
<tr class="separator:abf4ec63c7b08c440fd3520cdaecf57a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a5f8a31988380cf45fab6eaff3327c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c">push_back</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;child)</td></tr>
<tr class="memdesc:a78a5f8a31988380cf45fab6eaff3327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> to this node.  <a href="#a78a5f8a31988380cf45fab6eaff3327c">More...</a><br /></td></tr>
<tr class="separator:a78a5f8a31988380cf45fab6eaff3327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0eccee02bde40ac06bcd632cc5ad38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ade0eccee02bde40ac06bcd632cc5ad38">swap</a> (<a class="el" href="classxml_1_1node.html">node</a> &amp;other)</td></tr>
<tr class="memdesc:ade0eccee02bde40ac06bcd632cc5ad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this node with another one.  <a href="#ade0eccee02bde40ac06bcd632cc5ad38">More...</a><br /></td></tr>
<tr class="separator:ade0eccee02bde40ac06bcd632cc5ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944b8c4c154a91ad3e539776f05585a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae944b8c4c154a91ad3e539776f05585a">move_under</a> (<a class="el" href="classxml_1_1node.html">node</a> &amp;new_parent)</td></tr>
<tr class="memdesc:ae944b8c4c154a91ad3e539776f05585a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move this node under another parent.  <a href="#ae944b8c4c154a91ad3e539776f05585a">More...</a><br /></td></tr>
<tr class="separator:ae944b8c4c154a91ad3e539776f05585a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a837d35a85718501d8d083fd9a8d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html#acc984683e587a1cdc89b06930ab8cfee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a91a837d35a85718501d8d083fd9a8d85">size</a> () const </td></tr>
<tr class="memdesc:a91a837d35a85718501d8d083fd9a8d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children this nodes has.  <a href="#a91a837d35a85718501d8d083fd9a8d85">More...</a><br /></td></tr>
<tr class="separator:a91a837d35a85718501d8d083fd9a8d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ae6135e95a983fa89bf0dea26ce7da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ac5ae6135e95a983fa89bf0dea26ce7da">empty</a> () const </td></tr>
<tr class="memdesc:ac5ae6135e95a983fa89bf0dea26ce7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if this node has any children.  <a href="#ac5ae6135e95a983fa89bf0dea26ce7da">More...</a><br /></td></tr>
<tr class="separator:ac5ae6135e95a983fa89bf0dea26ce7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2858db5fed987227f80ff1c556b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a19f2858db5fed987227f80ff1c556b0b">begin</a> ()</td></tr>
<tr class="memdesc:a19f2858db5fed987227f80ff1c556b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points to the beginning of this node's children.  <a href="#a19f2858db5fed987227f80ff1c556b0b">More...</a><br /></td></tr>
<tr class="separator:a19f2858db5fed987227f80ff1c556b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1f89518cd7e1049b392ed07b06d299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a2a1f89518cd7e1049b392ed07b06d299">begin</a> () const </td></tr>
<tr class="memdesc:a2a1f89518cd7e1049b392ed07b06d299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the beginning of this node's children.  <a href="#a2a1f89518cd7e1049b392ed07b06d299">More...</a><br /></td></tr>
<tr class="separator:a2a1f89518cd7e1049b392ed07b06d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d53ce343ec4ef8678d18cf6c0b4552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552">end</a> ()</td></tr>
<tr class="memdesc:a92d53ce343ec4ef8678d18cf6c0b4552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points one past the last child for this node.  <a href="#a92d53ce343ec4ef8678d18cf6c0b4552">More...</a><br /></td></tr>
<tr class="separator:a92d53ce343ec4ef8678d18cf6c0b4552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fe0296d48c30c681d3426ae29a5a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a22fe0296d48c30c681d3426ae29a5a49">end</a> () const </td></tr>
<tr class="memdesc:a22fe0296d48c30c681d3426ae29a5a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points one past the last child for this node.  <a href="#a22fe0296d48c30c681d3426ae29a5a49">More...</a><br /></td></tr>
<tr class="separator:a22fe0296d48c30c681d3426ae29a5a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd609b79b54671575478022b3cd76dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#abd609b79b54671575478022b3cd76dca">self</a> ()</td></tr>
<tr class="memdesc:abd609b79b54671575478022b3cd76dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points back at this node.  <a href="#abd609b79b54671575478022b3cd76dca">More...</a><br /></td></tr>
<tr class="separator:abd609b79b54671575478022b3cd76dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4692918b524c2a83d0029c7b3b8a3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae4692918b524c2a83d0029c7b3b8a3b0">self</a> () const </td></tr>
<tr class="memdesc:ae4692918b524c2a83d0029c7b3b8a3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points back at this node.  <a href="#ae4692918b524c2a83d0029c7b3b8a3b0">More...</a><br /></td></tr>
<tr class="separator:ae4692918b524c2a83d0029c7b3b8a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a56ed0ea190af87784ea4869525ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aa8a56ed0ea190af87784ea4869525ec8">parent</a> ()</td></tr>
<tr class="memdesc:aa8a56ed0ea190af87784ea4869525ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points at the parent of this node.  <a href="#aa8a56ed0ea190af87784ea4869525ec8">More...</a><br /></td></tr>
<tr class="separator:aa8a56ed0ea190af87784ea4869525ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341cc718b7bba7124730ec7f3986b2dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a341cc718b7bba7124730ec7f3986b2dd">parent</a> () const </td></tr>
<tr class="memdesc:a341cc718b7bba7124730ec7f3986b2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points at the parent of this node.  <a href="#a341cc718b7bba7124730ec7f3986b2dd">More...</a><br /></td></tr>
<tr class="separator:a341cc718b7bba7124730ec7f3986b2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0e38e5095f0e682e00ea47d5d90a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a9c0e38e5095f0e682e00ea47d5d90a30">find</a> (const char *name)</td></tr>
<tr class="memdesc:a9c0e38e5095f0e682e00ea47d5d90a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node that has the given name.  <a href="#a9c0e38e5095f0e682e00ea47d5d90a30">More...</a><br /></td></tr>
<tr class="separator:a9c0e38e5095f0e682e00ea47d5d90a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad0683496c77a0e4b3eb73807e77d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a4ad0683496c77a0e4b3eb73807e77d59">find</a> (const char *name) const </td></tr>
<tr class="memdesc:a4ad0683496c77a0e4b3eb73807e77d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node that has the given name.  <a href="#a4ad0683496c77a0e4b3eb73807e77d59">More...</a><br /></td></tr>
<tr class="separator:a4ad0683496c77a0e4b3eb73807e77d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2bc3080530e7f48812a73907288ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aac2bc3080530e7f48812a73907288ac0">find</a> (const char *name, const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;start)</td></tr>
<tr class="memdesc:aac2bc3080530e7f48812a73907288ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node, starting with the given iterator, that has the given name.  <a href="#aac2bc3080530e7f48812a73907288ac0">More...</a><br /></td></tr>
<tr class="separator:aac2bc3080530e7f48812a73907288ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a443c7a8433b789d470ac98733164a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a16a443c7a8433b789d470ac98733164a">find</a> (const char *name, const <a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> &amp;start) const </td></tr>
<tr class="memdesc:a16a443c7a8433b789d470ac98733164a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node, starting with the given <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a>, that has the given name.  <a href="#a16a443c7a8433b789d470ac98733164a">More...</a><br /></td></tr>
<tr class="separator:a16a443c7a8433b789d470ac98733164a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c038a0f3fa58c3ed8069f8fe7a3a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a> ()</td></tr>
<tr class="memdesc:aa04c038a0f3fa58c3ed8069f8fe7a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element.  <a href="#aa04c038a0f3fa58c3ed8069f8fe7a3a4">More...</a><br /></td></tr>
<tr class="separator:aa04c038a0f3fa58c3ed8069f8fe7a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020514eeb1458eae549ba34ef53c9f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a020514eeb1458eae549ba34ef53c9f4f">elements</a> () const </td></tr>
<tr class="memdesc:a020514eeb1458eae549ba34ef53c9f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element.  <a href="#a020514eeb1458eae549ba34ef53c9f4f">More...</a><br /></td></tr>
<tr class="separator:a020514eeb1458eae549ba34ef53c9f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b5feaa00eb499257a25bd92992a55a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a">elements</a> (const char *name)</td></tr>
<tr class="memdesc:ac2b5feaa00eb499257a25bd92992a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element with name <em>name</em>.  <a href="#ac2b5feaa00eb499257a25bd92992a55a">More...</a><br /></td></tr>
<tr class="separator:ac2b5feaa00eb499257a25bd92992a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfafc43d760389ccdf3dbe5434b0f562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#adfafc43d760389ccdf3dbe5434b0f562">elements</a> (const char *name) const </td></tr>
<tr class="memdesc:adfafc43d760389ccdf3dbe5434b0f562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element with name <em>name</em>.  <a href="#adfafc43d760389ccdf3dbe5434b0f562">More...</a><br /></td></tr>
<tr class="separator:adfafc43d760389ccdf3dbe5434b0f562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade044c2b31477ea673e9839b3fb7cfcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ade044c2b31477ea673e9839b3fb7cfcf">insert</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:ade044c2b31477ea673e9839b3fb7cfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node.  <a href="#ade044c2b31477ea673e9839b3fb7cfcf">More...</a><br /></td></tr>
<tr class="separator:ade044c2b31477ea673e9839b3fb7cfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16013c5b1e30dff7613dd0be487379a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a16013c5b1e30dff7613dd0be487379a2">insert</a> (const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;position, const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a16013c5b1e30dff7613dd0be487379a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node.  <a href="#a16013c5b1e30dff7613dd0be487379a2">More...</a><br /></td></tr>
<tr class="separator:a16013c5b1e30dff7613dd0be487379a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f5714a2eae4aa9ec6846476bf78414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a08f5714a2eae4aa9ec6846476bf78414">replace</a> (const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;old_node, const <a class="el" href="classxml_1_1node.html">node</a> &amp;new_node)</td></tr>
<tr class="memdesc:a08f5714a2eae4aa9ec6846476bf78414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the node pointed to by the given iterator with another node.  <a href="#a08f5714a2eae4aa9ec6846476bf78414">More...</a><br /></td></tr>
<tr class="separator:a08f5714a2eae4aa9ec6846476bf78414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37a72ed93f838c58057c3865d21ff4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af37a72ed93f838c58057c3865d21ff4f">erase</a> (const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;to_erase)</td></tr>
<tr class="memdesc:af37a72ed93f838c58057c3865d21ff4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the node that is pointed to by the given iterator.  <a href="#af37a72ed93f838c58057c3865d21ff4f">More...</a><br /></td></tr>
<tr class="separator:af37a72ed93f838c58057c3865d21ff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b022990103fc1c806f5602cf7dbf58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a6b022990103fc1c806f5602cf7dbf58e">erase</a> (<a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> first, const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;last)</td></tr>
<tr class="memdesc:a6b022990103fc1c806f5602cf7dbf58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all nodes in the given range, from first to last.  <a href="#a6b022990103fc1c806f5602cf7dbf58e">More...</a><br /></td></tr>
<tr class="separator:a6b022990103fc1c806f5602cf7dbf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c78e6293283e648e11da94b6a9754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html#acc984683e587a1cdc89b06930ab8cfee">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab75c78e6293283e648e11da94b6a9754">erase</a> (const char *name)</td></tr>
<tr class="memdesc:ab75c78e6293283e648e11da94b6a9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all children nodes with the given name.  <a href="#ab75c78e6293283e648e11da94b6a9754">More...</a><br /></td></tr>
<tr class="separator:ab75c78e6293283e648e11da94b6a9754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b337ebcc316777526b8010eec985e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a1b337ebcc316777526b8010eec985e9f">clear</a> ()</td></tr>
<tr class="memdesc:a1b337ebcc316777526b8010eec985e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all children nodes.  <a href="#a1b337ebcc316777526b8010eec985e9f">More...</a><br /></td></tr>
<tr class="separator:a1b337ebcc316777526b8010eec985e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af224e8f7ccc7da323855a81018e23cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af224e8f7ccc7da323855a81018e23cab">sort</a> (const char *node_name, const char *attr_name)</td></tr>
<tr class="memdesc:af224e8f7ccc7da323855a81018e23cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all the children nodes of this node using one of their attributes.  <a href="#af224e8f7ccc7da323855a81018e23cab">More...</a><br /></td></tr>
<tr class="separator:af224e8f7ccc7da323855a81018e23cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11efe78e773372416c9e1b641394ced6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11efe78e773372416c9e1b641394ced6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a11efe78e773372416c9e1b641394ced6">sort</a> (T compare)</td></tr>
<tr class="memdesc:a11efe78e773372416c9e1b641394ced6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all the children nodes of this node using the given comparison function object.  <a href="#a11efe78e773372416c9e1b641394ced6">More...</a><br /></td></tr>
<tr class="separator:a11efe78e773372416c9e1b641394ced6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9f7512131665800d1ec4f2e4f71b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a6c9f7512131665800d1ec4f2e4f71b8b">node_to_string</a> (std::string &amp;xml) const </td></tr>
<tr class="memdesc:a6c9f7512131665800d1ec4f2e4f71b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the node and all its children into XML text and set the given string to that text.  <a href="#a6c9f7512131665800d1ec4f2e4f71b8b">More...</a><br /></td></tr>
<tr class="separator:a6c9f7512131665800d1ec4f2e4f71b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a18f2f94f9b57d7cee45090dcd127cc97"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a18f2f94f9b57d7cee45090dcd127cc97">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a18f2f94f9b57d7cee45090dcd127cc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a node and all of its children to the given stream.  <a href="#a18f2f94f9b57d7cee45090dcd127cc97">More...</a><br /></td></tr>
<tr class="separator:a18f2f94f9b57d7cee45090dcd127cc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> class is used to hold information about one XML node. </p>
<p>This includes the name of the node, the namespace of the node and attributes for the node. It also has an iterator whereby you can get to the children nodes.</p>
<p>It should be noted that any member function that returns a const char* returns a temporary value. The pointer that is returned will change with ANY operation to the <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. If you need the data to stick around a little longer you should put it inside a std::string. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="acc984683e587a1cdc89b06930ab8cfee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classxml_1_1node.html#acc984683e587a1cdc89b06930ab8cfee">xml::node::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a940647610d4ab69275a4889886b3cc73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">xml::node::node_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enum for the different types of XML nodes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442"></a>type_element&#160;</td><td class="fielddoc">
<p>XML element such as "&lt;chapter/&gt;". </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73ad3894a3c892717b03c8835774bade863"></a>type_text&#160;</td><td class="fielddoc">
<p>Text node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73ad08a3d7542cb53715b7eb9fe61afc43a"></a>type_cdata&#160;</td><td class="fielddoc">
<p>&lt;![CDATA[text]]&gt; </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73af9787bf54e2a8186b643aaabf94850ad"></a>type_pi&#160;</td><td class="fielddoc">
<p>Processing Instruction. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73aba376b6f894af123d9b0d2d3e9a87754"></a>type_comment&#160;</td><td class="fielddoc">
<p>XML comment. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73aeaad8ffd4e23a12dc244b10502c3630a"></a>type_entity&#160;</td><td class="fielddoc">
<p>Entity as in &amp;amp;. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73af09519f20be672ab7271f9588cb1f141"></a>type_entity_ref&#160;</td><td class="fielddoc">
<p>Entity ref. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a47e2014a31a4e8d5ce5b65610be5785a"></a>type_xinclude&#160;</td><td class="fielddoc">
<p>&lt;xi:include/&gt; node </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a90fb6fc3b406e9eabc666307a2182505"></a>type_document&#160;</td><td class="fielddoc">
<p>Document node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a5ad2575daf153e4c9342098834e800b1"></a>type_document_type&#160;</td><td class="fielddoc">
<p>DOCTYPE node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a510868f4ada4c9e121907f2926253dc9"></a>type_document_frag&#160;</td><td class="fielddoc">
<p>Document Fragment. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a4b4ec4e4ae3cd25413af91024e3d5c7d"></a>type_notation&#160;</td><td class="fielddoc">
<p>Notation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73ad067513260fc3cba8adb7e4046fa522f"></a>type_dtd&#160;</td><td class="fielddoc">
<p>DTD node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a71a97e98535c1961a23a781758921fec"></a>type_dtd_element&#160;</td><td class="fielddoc">
<p>DTD &lt;!ELEMENT&gt; node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73affbc2f67724bd953ca2cc4fb5f788668"></a>type_dtd_attribute&#160;</td><td class="fielddoc">
<p>DTD &lt;!ATTRLIST&gt; node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73acd5165d4b1015313b836696388511e04"></a>type_dtd_entity&#160;</td><td class="fielddoc">
<p>DTD &lt;!ENTITY&gt; </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a940647610d4ab69275a4889886b3cc73a22cffeab9645fd51d6341a7e6ef8de91"></a>type_dtd_namespace&#160;</td><td class="fielddoc">
<p>? </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a36262413721060030db06031e6932233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new blank <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </p>

</div>
</div>
<a class="anchor" id="a53e68e8305a47f686b22a2b39f60c5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> and set the name of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cfe3254a9552e9d398053c67bea42de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> given a name and content. </p>
<p>The content, if it's not an empty string, will be used to create a new child text node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new element. </td></tr>
    <tr><td class="paramname">content</td><td>The text that will be used to create a child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addc8f567fa1ec7ced116ed4fc2cd0c4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1cdata.html">cdata</a>&#160;</td>
          <td class="paramname"><em>cdata_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_cdata. </p>
<p>The cdata_info parameter should contain the contents of the CDATA section.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code" href="structxml_1_1node_1_1cdata.html">xml::node::cdata</a>(<span class="stringliteral">&quot;This is a CDATA section&quot;</span>));</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cdata_info</td><td>A cdata struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> what the content will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac5cf010b25c9f0ea2415ae99c6610bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1comment.html">comment</a>&#160;</td>
          <td class="paramname"><em>comment_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_comment. </p>
<p>The comment_info parameter should contain the contents of the XML comment.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code" href="structxml_1_1node_1_1comment.html">xml::node::comment</a>(<span class="stringliteral">&quot;This is an XML comment&quot;</span>));</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment_info</td><td>A comment struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> what the comment will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad1a164e7c81012e4a721531c34d6ba5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1pi.html">pi</a>&#160;</td>
          <td class="paramname"><em>pi_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_pi. </p>
<p>The pi_info parameter should contain the name of the XML processing instruction (PI), and optionally, the contents of the XML PI.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code" href="structxml_1_1node_1_1pi.html">xml::node::pi</a>(<span class="stringliteral">&quot;xslt&quot;</span>, <span class="stringliteral">&quot;stylesheet=\&quot;test.xsl\&quot;&quot;</span>));</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pi_info</td><td>A pi struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> what the name and contents of the XML PI are. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf2aa7ee2a4fee030e7c9bb0f64db859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1text.html">text</a>&#160;</td>
          <td class="paramname"><em>text_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> that is of type_text. </p>
<p>The text_info parameter should contain the text.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code" href="structxml_1_1node_1_1text.html">xml::node::text</a>(<span class="stringliteral">&quot;This is XML text&quot;</span>));</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text_info</td><td>A text struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> what the text will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a362154201ae3c6aa4213d4c8319e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> by copying another <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other node to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6cfd0d55c969e9407d09b56fe6d4fd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::~node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a19f2858db5fed987227f80ff1c556b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points to the beginning of this node's children. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the beginning of the children. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a1f89518cd7e1049b392ed07b06d299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the beginning of this node's children. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the beginning of the children. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b337ebcc316777526b8010eec985e9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all children nodes. </p>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa04c038a0f3fa58c3ed8069f8fe7a3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1nodes__view.html">xml::nodes_view</a> view(root.elements());</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classxml_1_1nodes__view_1_1iterator.html">xml::nodes_view::iterator</a> i = view.begin(); i != view.end(); ++i)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>View with all child elements or empty view if there aren't any. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1nodes__view.html" title="This class implements a view of XML nodes. ">nodes_view</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a020514eeb1458eae549ba34ef53c9f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1const__nodes__view.html">xml::const_nodes_view</a> view(root.elements());</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classxml_1_1nodes__view_1_1const__iterator.html">xml::const_nodes_view::const_iterator</a> i = view.begin();</div>
<div class="line">     i != view.end();</div>
<div class="line">     ++i)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>View with all child elements or empty view if there aren't any. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1const__nodes__view.html" title="This class implements a read-only view of XML nodes. ">const_nodes_view</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2b5feaa00eb499257a25bd92992a55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element with name <em>name</em>. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1nodes__view.html">xml::nodes_view</a> view(root.elements(<span class="stringliteral">&quot;person&quot;</span>));</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classxml_1_1nodes__view_1_1iterator.html">xml::nodes_view::iterator</a> i = view.begin(); i != view.end(); ++i)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the elements to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>View that contains only elements <em>name</em>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adfafc43d760389ccdf3dbe5434b0f562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element with name <em>name</em>. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1const__nodes__view.html">xml::const_nodes_view</a> view(root.elements(<span class="stringliteral">&quot;person&quot;</span>));</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classxml_1_1nodes__view_1_1const__iterator.html">xml::const_nodes_view::const_iterator</a> i = view.begin();</div>
<div class="line">     i != view.end();</div>
<div class="line">     ++i)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the elements to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>View that contains only elements <em>name</em>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac5ae6135e95a983fa89bf0dea26ce7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::node::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if this node has any children. </p>
<p>This is the same as <a class="el" href="classxml_1_1node.html#a91a837d35a85718501d8d083fd9a8d85" title="Returns the number of children this nodes has. ">xml::node::size()</a> == 0 except it is much faster.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this node DOES NOT have any children. </dd>
<dd>
False if this node does have children. </dd></dl>

</div>
</div>
<a class="anchor" id="a92d53ce343ec4ef8678d18cf6c0b4552"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator that points one past the last child for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A "one past the end" iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a22fe0296d48c30c681d3426ae29a5a49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points one past the last child for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A "one past the end" <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af37a72ed93f838c58057c3865d21ff4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>to_erase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the node that is pointed to by the given iterator. </p>
<p>The node and all its children will be removed from this node. This will invalidate any iterators that point to the node to be erased, or any pointers or references to that node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_erase</td><td>An iterator that points to the node to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node after the one being erased. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b022990103fc1c806f5602cf7dbf58e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all nodes in the given range, from first to last. </p>
<p>This will invalidate any iterators that point to the nodes to be erased, or any pointers or references to those nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first node in the range to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator that points one past the last node to erase. Think <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">xml::node::end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node after the last one being erased. </dd></dl>

</div>
</div>
<a class="anchor" id="ab75c78e6293283e648e11da94b6a9754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html#acc984683e587a1cdc89b06930ab8cfee">size_type</a> xml::node::erase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all children nodes with the given name. </p>
<p>This will find all nodes that have the given node name and remove them from this node. This will invalidate any iterators that point to the nodes to be erased, or any pointers or references to those nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of nodes to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c0e38e5095f0e682e00ea47d5d90a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node that has the given name. </p>
<p>If no such node can be found, this function will return the same iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> would return.</p>
<p>This function is not recursive. That is, it will not search down the tree for the requested node. Instead, it will only search one level deep, only checking the children of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> iterator if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a" title="Returns view of child nodes of type type_element with name name. ">elements(const char*)</a>, find(const char*, iterator) </dd></dl>

</div>
</div>
<a class="anchor" id="a4ad0683496c77a0e4b3eb73807e77d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node that has the given name. </p>
<p>If no such node can be found, this function will return the same <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> would return.</p>
<p>This function is not recursive. That is, it will not search down the tree for the requested node. Instead, it will only search one level deep, only checking the children of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#adfafc43d760389ccdf3dbe5434b0f562" title="Returns view of child nodes of type type_element with name name. ">elements(const char*) const</a>, find(const char*, const_iterator) const </dd></dl>

</div>
</div>
<a class="anchor" id="aac2bc3080530e7f48812a73907288ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node, starting with the given iterator, that has the given name. </p>
<p>If no such node can be found, this function will return the same iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> would return.</p>
<p>This function should be given an iterator to one of this node's children. The search will begin with that node and continue with all its sibliings. This function will not recurse down the tree, it only searches in one level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
    <tr><td class="paramname">start</td><td>Where to begin the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> iterator if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a" title="Returns view of child nodes of type type_element with name name. ">elements(const char*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16a443c7a8433b789d470ac98733164a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node, starting with the given <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a>, that has the given name. </p>
<p>If no such node can be found, this function will return the same <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> would return.</p>
<p>This function should be given a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> to one of this node's children. The search will begin with that node and continue with all its siblings. This function will not recurse down the tree, it only searches in one level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
    <tr><td class="paramname">start</td><td>Where to begin the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">end()</a> <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#adfafc43d760389ccdf3dbe5434b0f562" title="Returns view of child nodes of type type_element with name name. ">elements(const char*) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adfc02a04956784efa60a740a165b464b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1attributes.html">xml::attributes</a>&amp; xml::node::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of attributes. </p>
<p>You can use the returned object to get and set the attributes for this node. Make sure you use a reference to this returned object, to prevent a copy.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node. ">xml::attributes</a> object for this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aca4feeba192f50d0b0f34de3ff861941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxml_1_1attributes.html">xml::attributes</a>&amp; xml::node::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of attributes. </p>
<p>You can use the returned object to get the attributes for this node. Make sure you use a reference to this returned object, to prevent a copy.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node. ">xml::attributes</a> object for this node. </dd></dl>

</div>
</div>
<a class="anchor" id="ac072e7b9d99a9bcedaed6f139036e36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* xml::node::get_content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content for this text node. </p>
<p>If this node is not a text node but it has children nodes that are text nodes, the contents of those child nodes will be returned. If there is no content or these conditions do not apply, zero will be returned.</p>
<p>This function may change in the future to return std::string. Feedback is welcome.</p>
<dl class="section return"><dt>Returns</dt><dd>The content or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="aca0cf220ca2986163e623596dea5318b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* xml::node::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </p>
<p>This function may change in the future to return std::string. Feedback is welcome.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="ae460b5749a0efd275b4999ff33910dbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* xml::node::get_namespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The namespace of this node or NULL if no namespace is associated. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2b944576d7a197d20eaf4d9a2fa91422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">node_type</a> xml::node::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get this node's "type". </p>
<p>You can use that information to know what you can and cannot do with it.</p>
<dl class="section return"><dt>Returns</dt><dd>The node's type. </dd></dl>

</div>
</div>
<a class="anchor" id="ade044c2b31477ea673e9839b3fb7cfcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node. </p>
<p>The new node will be inserted at the end of the child list. This is similar to the <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node. ">xml::node::push_back</a> member function except that an iterator to the inserted node is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node to insert as a child of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted node. </dd></dl>

</div>
</div>
<a class="anchor" id="a16013c5b1e30dff7613dd0be487379a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node. </p>
<p>The new node will be inserted before the node pointed to by the given iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that points to the location where the new node should be inserted (before it). </td></tr>
    <tr><td class="paramname">n</td><td>The node to insert as a child of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted node. </dd></dl>

</div>
</div>
<a class="anchor" id="abf4ec63c7b08c440fd3520cdaecf57a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::node::is_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if this node is a text node or something like a text node, CDATA for example. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this node is a text node; false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae944b8c4c154a91ad3e539776f05585a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::move_under </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>new_parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move this node under another parent. </p>
<p>This node will become the last child of <em>new_parent</em>. Notice that this node must not be an ancestor of <em>new_parent</em>, in particular it shouldn't be the document root.</p>
<p>Currently this method can only be used to move nodes inside the same document.</p>
<p>All iterators pointing to this node are invalidated after the move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_parent</td><td>The new parent for the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6c9f7512131665800d1ec4f2e4f71b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::node_to_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the node and all its children into XML text and set the given string to that text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml</td><td>The string to set the node's XML data to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ea95ca4cd8eb9a27dc5f51dd61c0987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html">node</a>&amp; xml::node::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this node equal to some other node via assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other node to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a56ed0ea190af87784ea4869525ec8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points at the parent of this node. </p>
<p>If this node does not have a parent, this member function will return an "end" iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to this nodes parent. </dd>
<dd>
If no parent, returns the same iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">xml::node::end()</a> returns. </dd></dl>

</div>
</div>
<a class="anchor" id="a341cc718b7bba7124730ec7f3986b2dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points at the parent of this node. </p>
<p>If this node does not have a parent, this member function will return an "end" <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to this nodes parent. </dd>
<dd>
If no parent, returns the same <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">xml::node::end()</a> returns. </dd></dl>

</div>
</div>
<a class="anchor" id="a78a5f8a31988380cf45fab6eaff3327c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08f5714a2eae4aa9ec6846476bf78414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>old_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the node pointed to by the given iterator with another node. </p>
<p>The old node will be removed, including all its children, and replaced with the new node. This will invalidate any iterators that point to the node to be replaced, or any pointers or references to that node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_node</td><td>An iterator that points to the node that should be removed. </td></tr>
    <tr><td class="paramname">new_node</td><td>The node to put in old_node's place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the new node. </dd></dl>

</div>
</div>
<a class="anchor" id="abd609b79b54671575478022b3cd76dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points back at this node. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points at this node. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4692918b524c2a83d0029c7b3b8a3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points back at this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points at this node. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4625509cfbe6bf475f751d51ff6f10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_content </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the content of a node. </p>
<p>If this node is an element node, this function will remove all of its children nodes and replace them with one text node set to the given string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content of the text node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>content</em> is supposed to be a piece of XML CDATA, so it allows entity references, but XML special chars need to be escaped first. In particular, the '&amp;' character <em>must</em> be escaped as "&amp;amp;" unless it's part of entity reference. Not escaping <em>content</em> may result in truncation of data. Use <a class="el" href="classxml_1_1node.html#af7e81da5ef8eed970e974d1945c4d830" title="Set the content of a node to given text. ">set_text_content()</a> if <em>content</em> may contain special characters.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#af7e81da5ef8eed970e974d1945c4d830" title="Set the content of a node to given text. ">set_text_content()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a02d75545214dba0cf6d7efeb5ecfa2bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name for this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab847851d49148c231bd6630ee1b7e9b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_namespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>href</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. </p>
<p>If the default namespace is already set on this node, it is changed.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// n is &lt;foo/&gt;</span></div>
<div class="line">n.<a class="code" href="classxml_1_1node.html#ab847851d49148c231bd6630ee1b7e9b3">set_namespace</a>(<span class="stringliteral">&quot;http://example.com&quot;</span>)</div>
<div class="line"><span class="comment">// n is &lt;foo xmlns=&quot;http://example.com&quot;/&gt;</span></div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af7e81da5ef8eed970e974d1945c4d830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_text_content </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the content of a node to given text. </p>
<p>In contrast to <a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a" title="Set the content of a node. ">set_content()</a>, <em>content</em> is raw text, so unescaped XML special chars are allowed and entity references are not supported.</p>
<p>If this node is an element node, this function will remove all of its children nodes and replace them with one text node set to the given string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a" title="Set the content of a node. ">set_content()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a91a837d35a85718501d8d083fd9a8d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html#acc984683e587a1cdc89b06930ab8cfee">size_type</a> xml::node::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of children this nodes has. </p>
<p>If you just want to know how if this node has children or not, you should use <a class="el" href="classxml_1_1node.html#ac5ae6135e95a983fa89bf0dea26ce7da" title="Find out if this node has any children. ">xml::node::empty()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of children this node has. </dd></dl>

</div>
</div>
<a class="anchor" id="af224e8f7ccc7da323855a81018e23cab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::sort </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attr_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort all the children nodes of this node using one of their attributes. </p>
<p>Only nodes that are of <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442" title="XML element such as &quot;<chapter/>&quot;. ">xml::node::type_element</a> will be sorted, and they must have the given node_name.</p>
<p>The sorting is done by calling std::strcmp on the value of the given attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>The name of the nodes to sort. </td></tr>
    <tr><td class="paramname">attr_name</td><td>The attribute to sort on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11efe78e773372416c9e1b641394ced6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::sort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort all the children nodes of this node using the given comparison function object. </p>
<p>All element type nodes will be considered for sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The binary function object to call in order to sort all child nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade0eccee02bde40ac06bcd632cc5ad38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap this node with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other node to swap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a18f2f94f9b57d7cee45090dcd127cc97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a node and all of its children to the given stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write the node as XML. </td></tr>
    <tr><td class="paramname">n</td><td>The node to write to the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xmlwrapp/<a class="el" href="node_8h_source.html">node.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 2 2015 21:32:54 for xmlwrapp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
