<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>xmlwrapp: xml::document Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xmlwrapp
   </div>
   <div id="projectbrief">Lightweight C++ XML parsing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexml.html">xml</a></li><li class="navelem"><a class="el" href="classxml_1_1document.html">document</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classxml_1_1document-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xml::document Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> class is used to hold the XML tree and various bits of information about it.  
 <a href="classxml_1_1document.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="document_8h_source.html">document.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a91b1929c9458eee9d88bed15edaff51e"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a91b1929c9458eee9d88bed15edaff51e">size_type</a></td></tr>
<tr class="memdesc:a91b1929c9458eee9d88bed15edaff51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type  <a href="#a91b1929c9458eee9d88bed15edaff51e">More...</a><br /></td></tr>
<tr class="separator:a91b1929c9458eee9d88bed15edaff51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7eb901e7ea56a060911241dbbceb6283"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a7eb901e7ea56a060911241dbbceb6283">document</a> ()</td></tr>
<tr class="memdesc:a7eb901e7ea56a060911241dbbceb6283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new XML document with the default settings.  <a href="#a7eb901e7ea56a060911241dbbceb6283">More...</a><br /></td></tr>
<tr class="separator:a7eb901e7ea56a060911241dbbceb6283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaf8854142266d83054253c0eb87eac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#aaeaf8854142266d83054253c0eb87eac">document</a> (const char *root_name)</td></tr>
<tr class="memdesc:aaeaf8854142266d83054253c0eb87eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new XML document and set the name of the root element to the given text.  <a href="#aaeaf8854142266d83054253c0eb87eac">More...</a><br /></td></tr>
<tr class="separator:aaeaf8854142266d83054253c0eb87eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae57dd350cf8d410f054d53ff22f5f02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#aae57dd350cf8d410f054d53ff22f5f02">document</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:aae57dd350cf8d410f054d53ff22f5f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new XML document and set the root node.  <a href="#aae57dd350cf8d410f054d53ff22f5f02">More...</a><br /></td></tr>
<tr class="separator:aae57dd350cf8d410f054d53ff22f5f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a6ff60344b3f5e487b232443a6e7a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#ac0a6ff60344b3f5e487b232443a6e7a2">document</a> (const char *filename, <a class="el" href="classxml_1_1error__handler.html">error_handler</a> &amp;on_error)</td></tr>
<tr class="memdesc:ac0a6ff60344b3f5e487b232443a6e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load XML document from given file.  <a href="#ac0a6ff60344b3f5e487b232443a6e7a2">More...</a><br /></td></tr>
<tr class="separator:ac0a6ff60344b3f5e487b232443a6e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2b5b8876a6839d6e081953a949ba24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#aab2b5b8876a6839d6e081953a949ba24">document</a> (const char *data, <a class="el" href="classxml_1_1document.html#a91b1929c9458eee9d88bed15edaff51e">size_type</a> <a class="el" href="classxml_1_1document.html#a3395f05721e5fbcc9a3f3474548dc3cd">size</a>, <a class="el" href="classxml_1_1error__handler.html">error_handler</a> &amp;on_error=<a class="el" href="namespacexml.html#a0364ca612c720ffef872672fc19bcf10">throw_on_error</a>)</td></tr>
<tr class="memdesc:aab2b5b8876a6839d6e081953a949ba24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load XML document from given data.  <a href="#aab2b5b8876a6839d6e081953a949ba24">More...</a><br /></td></tr>
<tr class="separator:aab2b5b8876a6839d6e081953a949ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c19541bcca96d2adfdbb79bf10eb2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a35c19541bcca96d2adfdbb79bf10eb2c">document</a> (const <a class="el" href="classxml_1_1document.html">document</a> &amp;other)</td></tr>
<tr class="memdesc:a35c19541bcca96d2adfdbb79bf10eb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct a new XML document.  <a href="#a35c19541bcca96d2adfdbb79bf10eb2c">More...</a><br /></td></tr>
<tr class="separator:a35c19541bcca96d2adfdbb79bf10eb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17a47e5b37022eef699d196b0eb0411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1document.html">document</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#ae17a47e5b37022eef699d196b0eb0411">operator=</a> (const <a class="el" href="classxml_1_1document.html">document</a> &amp;other)</td></tr>
<tr class="memdesc:ae17a47e5b37022eef699d196b0eb0411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another document object into this one using the assignment operator.  <a href="#ae17a47e5b37022eef699d196b0eb0411">More...</a><br /></td></tr>
<tr class="separator:ae17a47e5b37022eef699d196b0eb0411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c927a467274467bc28be01a9af3d4b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a5c927a467274467bc28be01a9af3d4b2">swap</a> (<a class="el" href="classxml_1_1document.html">document</a> &amp;other)</td></tr>
<tr class="memdesc:a5c927a467274467bc28be01a9af3d4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap one <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> object for another.  <a href="#a5c927a467274467bc28be01a9af3d4b2">More...</a><br /></td></tr>
<tr class="separator:a5c927a467274467bc28be01a9af3d4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0890aba6da0ae25b1ed31be302d13dea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a0890aba6da0ae25b1ed31be302d13dea">~document</a> ()</td></tr>
<tr class="memdesc:a0890aba6da0ae25b1ed31be302d13dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after an XML document object.  <a href="#a0890aba6da0ae25b1ed31be302d13dea">More...</a><br /></td></tr>
<tr class="separator:a0890aba6da0ae25b1ed31be302d13dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3d7caba72ddd37a62964e0fabcbc9c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a1f3d7caba72ddd37a62964e0fabcbc9c">get_root_node</a> () const </td></tr>
<tr class="memdesc:a1f3d7caba72ddd37a62964e0fabcbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the root node of this document.  <a href="#a1f3d7caba72ddd37a62964e0fabcbc9c">More...</a><br /></td></tr>
<tr class="separator:a1f3d7caba72ddd37a62964e0fabcbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61513cff40e18219f876fab9ea61afa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a61513cff40e18219f876fab9ea61afa0">get_root_node</a> ()</td></tr>
<tr class="memdesc:a61513cff40e18219f876fab9ea61afa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the root node of this document.  <a href="#a61513cff40e18219f876fab9ea61afa0">More...</a><br /></td></tr>
<tr class="separator:a61513cff40e18219f876fab9ea61afa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d1ded0c12df7783adb8994df3ffb78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a33d1ded0c12df7783adb8994df3ffb78">set_root_node</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a33d1ded0c12df7783adb8994df3ffb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root node to the given node.  <a href="#a33d1ded0c12df7783adb8994df3ffb78">More...</a><br /></td></tr>
<tr class="separator:a33d1ded0c12df7783adb8994df3ffb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dff4493062cbed749fbe5be7a4a594"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a60dff4493062cbed749fbe5be7a4a594">get_version</a> () const </td></tr>
<tr class="memdesc:a60dff4493062cbed749fbe5be7a4a594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the XML version for this document.  <a href="#a60dff4493062cbed749fbe5be7a4a594">More...</a><br /></td></tr>
<tr class="separator:a60dff4493062cbed749fbe5be7a4a594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840fa57b244881b181e17e8b6fe69be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a840fa57b244881b181e17e8b6fe69be0">set_version</a> (const char *version)</td></tr>
<tr class="memdesc:a840fa57b244881b181e17e8b6fe69be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the XML version number for this document.  <a href="#a840fa57b244881b181e17e8b6fe69be0">More...</a><br /></td></tr>
<tr class="separator:a840fa57b244881b181e17e8b6fe69be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b6d812883a770e4a799e34a2497d2a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#ad4b6d812883a770e4a799e34a2497d2a">get_encoding</a> () const </td></tr>
<tr class="memdesc:ad4b6d812883a770e4a799e34a2497d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the XML encoding for this document.  <a href="#ad4b6d812883a770e4a799e34a2497d2a">More...</a><br /></td></tr>
<tr class="separator:ad4b6d812883a770e4a799e34a2497d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98362cce0702894e65aed5fc3244a1b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a98362cce0702894e65aed5fc3244a1b9">set_encoding</a> (const char *encoding)</td></tr>
<tr class="memdesc:a98362cce0702894e65aed5fc3244a1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the XML encoding string.  <a href="#a98362cce0702894e65aed5fc3244a1b9">More...</a><br /></td></tr>
<tr class="separator:a98362cce0702894e65aed5fc3244a1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4f2a10ff6de52b6047edd04e908c14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a3a4f2a10ff6de52b6047edd04e908c14">get_is_standalone</a> () const </td></tr>
<tr class="memdesc:a3a4f2a10ff6de52b6047edd04e908c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if the current document is a standalone document.  <a href="#a3a4f2a10ff6de52b6047edd04e908c14">More...</a><br /></td></tr>
<tr class="separator:a3a4f2a10ff6de52b6047edd04e908c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad825b78011dde8d6d2dc4b747bdd0853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#ad825b78011dde8d6d2dc4b747bdd0853">set_is_standalone</a> (bool sa)</td></tr>
<tr class="memdesc:ad825b78011dde8d6d2dc4b747bdd0853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the standalone flag.  <a href="#ad825b78011dde8d6d2dc4b747bdd0853">More...</a><br /></td></tr>
<tr class="separator:ad825b78011dde8d6d2dc4b747bdd0853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90470924ba6080469ce078a7659f3813"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a90470924ba6080469ce078a7659f3813">process_xinclude</a> ()</td></tr>
<tr class="memdesc:a90470924ba6080469ce078a7659f3813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk through the document and expand &lt;xi:include&gt; elements.  <a href="#a90470924ba6080469ce078a7659f3813">More...</a><br /></td></tr>
<tr class="separator:a90470924ba6080469ce078a7659f3813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81e139cc8150bf1a8ae7c7a082fb868"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#ac81e139cc8150bf1a8ae7c7a082fb868">has_internal_subset</a> () const </td></tr>
<tr class="memdesc:ac81e139cc8150bf1a8ae7c7a082fb868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if this document has an internal subset.  <a href="#ac81e139cc8150bf1a8ae7c7a082fb868">More...</a><br /></td></tr>
<tr class="separator:ac81e139cc8150bf1a8ae7c7a082fb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb73fa0aacbcbe2e861a170b91221de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a8fb73fa0aacbcbe2e861a170b91221de">has_external_subset</a> () const </td></tr>
<tr class="memdesc:a8fb73fa0aacbcbe2e861a170b91221de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if this document has an external subset.  <a href="#a8fb73fa0aacbcbe2e861a170b91221de">More...</a><br /></td></tr>
<tr class="separator:a8fb73fa0aacbcbe2e861a170b91221de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7be82f4085c26d1244f7f90f01f4f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a9a7be82f4085c26d1244f7f90f01f4f6">validate</a> ()</td></tr>
<tr class="memdesc:a9a7be82f4085c26d1244f7f90f01f4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate this document against the DTD that has been attached to it.  <a href="#a9a7be82f4085c26d1244f7f90f01f4f6">More...</a><br /></td></tr>
<tr class="separator:a9a7be82f4085c26d1244f7f90f01f4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6eb6386e64db4d5849b40c78bc87e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#afb6eb6386e64db4d5849b40c78bc87e0">validate</a> (const char *dtdname)</td></tr>
<tr class="memdesc:afb6eb6386e64db4d5849b40c78bc87e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given DTD and try to validate this document against it.  <a href="#afb6eb6386e64db4d5849b40c78bc87e0">More...</a><br /></td></tr>
<tr class="separator:afb6eb6386e64db4d5849b40c78bc87e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395f05721e5fbcc9a3f3474548dc3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1document.html#a91b1929c9458eee9d88bed15edaff51e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a3395f05721e5fbcc9a3f3474548dc3cd">size</a> () const </td></tr>
<tr class="memdesc:a3395f05721e5fbcc9a3f3474548dc3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of child nodes of this document.  <a href="#a3395f05721e5fbcc9a3f3474548dc3cd">More...</a><br /></td></tr>
<tr class="separator:a3395f05721e5fbcc9a3f3474548dc3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cc85b3ee01bcf5b457f54b64e27676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a30cc85b3ee01bcf5b457f54b64e27676">begin</a> ()</td></tr>
<tr class="memdesc:a30cc85b3ee01bcf5b457f54b64e27676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first child node of this document.  <a href="#a30cc85b3ee01bcf5b457f54b64e27676">More...</a><br /></td></tr>
<tr class="separator:a30cc85b3ee01bcf5b457f54b64e27676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d026301345b4f7b7e97a7dc193c2b14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">node::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a8d026301345b4f7b7e97a7dc193c2b14">begin</a> () const </td></tr>
<tr class="memdesc:a8d026301345b4f7b7e97a7dc193c2b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator to the first child node of this document.  <a href="#a8d026301345b4f7b7e97a7dc193c2b14">More...</a><br /></td></tr>
<tr class="separator:a8d026301345b4f7b7e97a7dc193c2b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621f1d7e56bd6585b8dbf060aef67ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a5621f1d7e56bd6585b8dbf060aef67ce">end</a> ()</td></tr>
<tr class="memdesc:a5621f1d7e56bd6585b8dbf060aef67ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points one past the last child node for this document.  <a href="#a5621f1d7e56bd6585b8dbf060aef67ce">More...</a><br /></td></tr>
<tr class="separator:a5621f1d7e56bd6585b8dbf060aef67ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9992b24dad4a806308d334879459e4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">node::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a9992b24dad4a806308d334879459e4f8">end</a> () const </td></tr>
<tr class="memdesc:a9992b24dad4a806308d334879459e4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator that points one past the last child node for this document.  <a href="#a9992b24dad4a806308d334879459e4f8">More...</a><br /></td></tr>
<tr class="separator:a9992b24dad4a806308d334879459e4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970a576771229cd8b20267e6123ac63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a9970a576771229cd8b20267e6123ac63">push_back</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;child)</td></tr>
<tr class="memdesc:a9970a576771229cd8b20267e6123ac63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> to this document.  <a href="#a9970a576771229cd8b20267e6123ac63">More...</a><br /></td></tr>
<tr class="separator:a9970a576771229cd8b20267e6123ac63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d222f07ce77f9e421acb9471488694c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a5d222f07ce77f9e421acb9471488694c">insert</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a5d222f07ce77f9e421acb9471488694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node.  <a href="#a5d222f07ce77f9e421acb9471488694c">More...</a><br /></td></tr>
<tr class="separator:a5d222f07ce77f9e421acb9471488694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8f4fe7d88e3eaac9f7010297a018cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a7e8f4fe7d88e3eaac9f7010297a018cb">insert</a> (<a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> position, const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a7e8f4fe7d88e3eaac9f7010297a018cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node.  <a href="#a7e8f4fe7d88e3eaac9f7010297a018cb">More...</a><br /></td></tr>
<tr class="separator:a7e8f4fe7d88e3eaac9f7010297a018cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5f36635a30dbab2ee2de6b70ae50f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a0e5f36635a30dbab2ee2de6b70ae50f7">replace</a> (<a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> old_node, const <a class="el" href="classxml_1_1node.html">node</a> &amp;new_node)</td></tr>
<tr class="memdesc:a0e5f36635a30dbab2ee2de6b70ae50f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the node pointed to by the given iterator with another node.  <a href="#a0e5f36635a30dbab2ee2de6b70ae50f7">More...</a><br /></td></tr>
<tr class="separator:a0e5f36635a30dbab2ee2de6b70ae50f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fb2a24ada58528d18b1b922ebc9c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a92fb2a24ada58528d18b1b922ebc9c74">erase</a> (<a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> to_erase)</td></tr>
<tr class="memdesc:a92fb2a24ada58528d18b1b922ebc9c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the node that is pointed to by the given iterator.  <a href="#a92fb2a24ada58528d18b1b922ebc9c74">More...</a><br /></td></tr>
<tr class="separator:a92fb2a24ada58528d18b1b922ebc9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ab507c2dfafb25c21d26debba0690c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a48ab507c2dfafb25c21d26debba0690c">erase</a> (<a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> first, <a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> last)</td></tr>
<tr class="memdesc:a48ab507c2dfafb25c21d26debba0690c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all nodes in the given range, from first to last.  <a href="#a48ab507c2dfafb25c21d26debba0690c">More...</a><br /></td></tr>
<tr class="separator:a48ab507c2dfafb25c21d26debba0690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eec6f9f0016d5cdeb8f742e128105ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#a1eec6f9f0016d5cdeb8f742e128105ea">save_to_string</a> (std::string &amp;s) const </td></tr>
<tr class="memdesc:a1eec6f9f0016d5cdeb8f742e128105ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the XML document tree into XML text data and place it into the given string.  <a href="#a1eec6f9f0016d5cdeb8f742e128105ea">More...</a><br /></td></tr>
<tr class="separator:a1eec6f9f0016d5cdeb8f742e128105ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c75af1904fc528cacd4e43ddc7db6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#aa1c75af1904fc528cacd4e43ddc7db6e">save_to_file</a> (const char *filename, int compression_level=0) const </td></tr>
<tr class="memdesc:aa1c75af1904fc528cacd4e43ddc7db6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the XML document tree into XML text data and place it into the given filename.  <a href="#aa1c75af1904fc528cacd4e43ddc7db6e">More...</a><br /></td></tr>
<tr class="separator:aa1c75af1904fc528cacd4e43ddc7db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aab86896fa496224fef9ae4c802ecc1b5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1document.html#aab86896fa496224fef9ae4c802ecc1b5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classxml_1_1document.html">document</a> &amp;doc)</td></tr>
<tr class="memdesc:aab86896fa496224fef9ae4c802ecc1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the XML document tree into XML text data and then insert it into the given stream.  <a href="#aab86896fa496224fef9ae4c802ecc1b5">More...</a><br /></td></tr>
<tr class="separator:aab86896fa496224fef9ae4c802ecc1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> class is used to hold the XML tree and various bits of information about it. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a91b1929c9458eee9d88bed15edaff51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classxml_1_1document.html#a91b1929c9458eee9d88bed15edaff51e">xml::document::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7eb901e7ea56a060911241dbbceb6283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::document </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new XML document with the default settings. </p>
<p>The new document will contain a root node with a name of "blank". </p>

</div>
</div>
<a class="anchor" id="aaeaf8854142266d83054253c0eb87eac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::document </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>root_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new XML document and set the name of the root element to the given text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_name</td><td>What to set the name of the root element to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <code><a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document(xml::node(root_name))</a></code> constructor instead. </dd></dl>

</div>
</div>
<a class="anchor" id="aae57dd350cf8d410f054d53ff22f5f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::document </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new XML document and set the root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node to use as the root node. n will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0a6ff60344b3f5e487b232443a6e7a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::document </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxml_1_1error__handler.html">error_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load XML document from given file. </p>
<p>Errors are handled by <em>on_error</em> handler; if you pass <a class="el" href="namespacexml.html#a0364ca612c720ffef872672fc19bcf10" title="Error handler object that throws on any error. ">xml::throw_on_error</a>, <a class="el" href="classxml_1_1exception.html" title="This exception class is thrown by xmlwrapp for all runtime XML-related errors. ">xml::exception</a> is thrown on errors. If there's a fatal error that prevents the document from being loaded and the error handler doesn't throw an exception, the constructor will throw <a class="el" href="classxml_1_1exception.html" title="This exception class is thrown by xmlwrapp for all runtime XML-related errors. ">xml::exception</a> anyway.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to parse. </td></tr>
    <tr><td class="paramname">on_error</td><td>Handler called to process errors and warnings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aab2b5b8876a6839d6e081953a949ba24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::document </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxml_1_1document.html#a91b1929c9458eee9d88bed15edaff51e">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxml_1_1error__handler.html">error_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>on_error</em> = <code><a class="el" href="namespacexml.html#a0364ca612c720ffef872672fc19bcf10">throw_on_error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load XML document from given data. </p>
<p>Errors are handled by <em>on_error</em> handler; by default, <a class="el" href="classxml_1_1exception.html" title="This exception class is thrown by xmlwrapp for all runtime XML-related errors. ">xml::exception</a> is thrown on errors. If there's a fatal error that prevents the document from being loaded and the error handler doesn't throw an exception, the constructor will throw <a class="el" href="classxml_1_1exception.html" title="This exception class is thrown by xmlwrapp for all runtime XML-related errors. ">xml::exception</a> anyway.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The XML data to parse. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the XML data to parse. </td></tr>
    <tr><td class="paramname">on_error</td><td>Handler called to process errors and warnings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a35c19541bcca96d2adfdbb79bf10eb2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::document </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy construct a new XML document. </p>
<p>The new document will be an exact copy of the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other document object to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0890aba6da0ae25b1ed31be302d13dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::document::~document </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after an XML document object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a30cc85b3ee01bcf5b457f54b64e27676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator to the first child node of this document. </p>
<p>If what you really wanted was the root node (the first element) you should use the <a class="el" href="classxml_1_1document.html#a61513cff40e18219f876fab9ea61afa0" title="Get a reference to the root node of this document. ">get_root_node()</a> member function instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> that points to the first child node. </dd>
<dd>
An end iterator if there are no children in this document </dd></dl>

</div>
</div>
<a class="anchor" id="a8d026301345b4f7b7e97a7dc193c2b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">node::const_iterator</a> xml::document::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const_iterator to the first child node of this document. </p>
<p>If what you really wanted was the root node (the first element) you should use the <a class="el" href="classxml_1_1document.html#a61513cff40e18219f876fab9ea61afa0" title="Get a reference to the root node of this document. ">get_root_node()</a> member function instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">xml::node::const_iterator</a> that points to the first child node. </dd>
<dd>
An end const_iterator if there are no children in this document. </dd></dl>

</div>
</div>
<a class="anchor" id="a5621f1d7e56bd6585b8dbf060aef67ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points one past the last child node for this document. </p>
<dl class="section return"><dt>Returns</dt><dd>An end <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9992b24dad4a806308d334879459e4f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">node::const_iterator</a> xml::document::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const_iterator that points one past the last child node for this document. </p>
<dl class="section return"><dt>Returns</dt><dd>An end <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">xml::node::const_iterator</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a92fb2a24ada58528d18b1b922ebc9c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td>
          <td class="paramname"><em>to_erase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the node that is pointed to by the given iterator. </p>
<p>The node and all its children will be removed from this node. This will invalidate any iterators that point to the node to be erased, or any pointers or references to that node.</p>
<p>Do not remove the root node using this member function. The same rules that apply to push_back apply here. If you try to erase the root node, an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_erase</td><td>An iterator that points to the node to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node after the one being erased. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1document.html#a9970a576771229cd8b20267e6123ac63" title="Add a child xml::node to this document. ">xml::document::push_back</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a48ab507c2dfafb25c21d26debba0690c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all nodes in the given range, from first to last. </p>
<p>This will invalidate any iterators that point to the nodes to be erased, or any pointers or references to those nodes.</p>
<p>Do not remove the root node using this member function. The same rules that apply to push_back apply here. If you try to erase the root node, an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first node in the range to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator that points one past the last node to erase. Think <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">xml::node::end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node after the last one being erased. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1document.html#a9970a576771229cd8b20267e6123ac63" title="Add a child xml::node to this document. ">xml::document::push_back</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4b6d812883a770e4a799e34a2497d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; xml::document::get_encoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the XML encoding for this document. </p>
<p>The default encoding is ISO-8859-1.</p>
<dl class="section return"><dt>Returns</dt><dd>The encoding string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a4f2a10ff6de52b6047edd04e908c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::get_is_standalone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if the current document is a standalone document. </p>
<p>For generated documents, this will be the default. For parsed documents this will be set based on the XML processing instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this document is standalone. </dd>
<dd>
False if this document is not standalone. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f3d7caba72ddd37a62964e0fabcbc9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxml_1_1node.html">node</a>&amp; xml::document::get_root_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the root node of this document. </p>
<p>If no root node has been set, the returned node will be a blank node. You should take caution to use a reference so that you don't copy the whole node tree!</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the root node. </dd></dl>

</div>
</div>
<a class="anchor" id="a61513cff40e18219f876fab9ea61afa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html">node</a>&amp; xml::document::get_root_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the root node of this document. </p>
<p>If no root node has been set, the returned node will be a blank node. You should take caution to use a reference so that you don't copy the whole node tree!</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the root node. </dd></dl>

</div>
</div>
<a class="anchor" id="a60dff4493062cbed749fbe5be7a4a594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; xml::document::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the XML version for this document. </p>
<p>For generated documents, the version will be the default. For parsed documents, this will be the version from the XML processing instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>The XML version string for this document. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fb73fa0aacbcbe2e861a170b91221de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::has_external_subset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test to see if this document has an external subset. </p>
<p>That is, it references a DTD from an external source, such as a file or URL.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this document has an external subset. </dd>
<dd>
False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac81e139cc8150bf1a8ae7c7a082fb868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::has_internal_subset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test to see if this document has an internal subset. </p>
<p>That is, DTD data that is declared within the XML document itself.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this document has an internal subset. </dd>
<dd>
False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d222f07ce77f9e421acb9471488694c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node. </p>
<p>The new node will be inserted at the end of the child list. This is similar to the <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node. ">xml::node::push_back</a> member function except that an iterator to the inserted node is returned.</p>
<p>The rules from the push_back member function apply here. Don't add a node of type element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node to insert as a child of this document. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1document.html#a9970a576771229cd8b20267e6123ac63" title="Add a child xml::node to this document. ">xml::document::push_back</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e8f4fe7d88e3eaac9f7010297a018cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node. </p>
<p>The new node will be inserted before the node pointed to by the given iterator.</p>
<p>The rules from the push_back member function apply here. Don't add a node of type element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that points to the location where the new node should be inserted (before it). </td></tr>
    <tr><td class="paramname">n</td><td>The node to insert as a child of this document. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1document.html#a9970a576771229cd8b20267e6123ac63" title="Add a child xml::node to this document. ">xml::document::push_back</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae17a47e5b37022eef699d196b0eb0411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1document.html">document</a>&amp; xml::document::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy another document object into this one using the assignment operator. </p>
<p>This document object will be an exact copy of the other document after the assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The document to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this. </dd></dl>

</div>
</div>
<a class="anchor" id="a90470924ba6080469ce078a7659f3813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::process_xinclude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk through the document and expand &lt;xi:include&gt; elements. </p>
<p>For more information, please see the w3c recommendation for XInclude. <a href="http://www.w3.org/2001/XInclude">http://www.w3.org/2001/XInclude</a>.</p>
<p>The return value of this function may change to int after a bug has been fixed in libxml2 (xmlXIncludeDoProcess).</p>
<dl class="section return"><dt>Returns</dt><dd>False if there was an error with substitutions. </dd>
<dd>
True if there were no errors (with or without substitutions). </dd></dl>

</div>
</div>
<a class="anchor" id="a9970a576771229cd8b20267e6123ac63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> to this document. </p>
<p>You should not add a element type node, since there can only be one root node. This member function is only useful for adding processing instructions, comments, etc.. If you do try to add a node of type element, an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e5f36635a30dbab2ee2de6b70ae50f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a> xml::document::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">node::iterator</a>&#160;</td>
          <td class="paramname"><em>old_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the node pointed to by the given iterator with another node. </p>
<p>The old node will be removed, including all its children, and replaced with the new node. This will invalidate any iterators that point to the node to be replaced, or any pointers or references to that node.</p>
<p>Do not replace this root node with this member function. The same rules that apply to push_back apply here. If you try to replace a node of type element, an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_node</td><td>An iterator that points to the node that should be removed. </td></tr>
    <tr><td class="paramname">new_node</td><td>The node to put in old_node's place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the new node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1document.html#a9970a576771229cd8b20267e6123ac63" title="Add a child xml::node to this document. ">xml::document::push_back</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c75af1904fc528cacd4e43ddc7db6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::save_to_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compression_level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the XML document tree into XML text data and place it into the given filename. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to place the XML text data into. </td></tr>
    <tr><td class="paramname">compression_level</td><td>0 is no compression, 1-9 allowed, where 1 is for better speed, and 9 is for smaller size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the data was saved successfully. </dd>
<dd>
False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1eec6f9f0016d5cdeb8f742e128105ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::save_to_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the XML document tree into XML text data and place it into the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to place the XML text data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98362cce0702894e65aed5fc3244a1b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::set_encoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the XML encoding string. </p>
<p>If you don't set this, it will default to ISO-8859-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>The XML encoding to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad825b78011dde8d6d2dc4b747bdd0853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::set_is_standalone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the standalone flag. </p>
<p>This will show up in the XML output in the correct processing instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>What to set the standalone flag to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33d1ded0c12df7783adb8994df3ffb78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::set_root_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the root node to the given node. </p>
<p>A full copy is made and stored in the document object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new root node to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a840fa57b244881b181e17e8b6fe69be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::set_version </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the XML version number for this document. </p>
<p>This version string will be used when generating the XML output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>The version string to use, like "1.0". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3395f05721e5fbcc9a3f3474548dc3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1document.html#a91b1929c9458eee9d88bed15edaff51e">size_type</a> xml::document::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of child nodes of this document. </p>
<p>This will always be at least one, since all xmlwrapp documents must have a root node. This member function is useful to find out how many document children there are, including processing instructions, comments, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of children nodes that this document has. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c927a467274467bc28be01a9af3d4b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::document::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap one <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> object for another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other document to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a7be82f4085c26d1244f7f90f01f4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate this document against the DTD that has been attached to it. </p>
<p>This would happen at parse time if there was a !DOCTYPE definition. If the DTD is valid, and the document is valid, this member function will return true.</p>
<p>If it returns false, you may want to send the document through xmllint to get the actual error messages.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the document is valid. </dd>
<dd>
False if there was a problem with the DTD or XML doc. </dd></dl>

</div>
</div>
<a class="anchor" id="afb6eb6386e64db4d5849b40c78bc87e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::document::validate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dtdname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given DTD and try to validate this document against it. </p>
<p>If the DTD is valid, and the document is valid, this member function will return true.</p>
<p>If it returns false, you may want to send the document through xmllint to get the actual error messages.</p>
<p>This member function will add the parsed DTD to this document as the external subset after the validation. If there is already an external DTD attached to this document it will be removed and deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtdname</td><td>A filename or URL for the DTD to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the document is valid. </dd>
<dd>
False if there was a problem with the DTD or XML doc. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aab86896fa496224fef9ae4c802ecc1b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1document.html">document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the XML document tree into XML text data and then insert it into the given stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to insert the XML into. </td></tr>
    <tr><td class="paramname">doc</td><td>The document to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream from the first parameter. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xmlwrapp/<a class="el" href="document_8h_source.html">document.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 2 2015 21:32:54 for xmlwrapp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
