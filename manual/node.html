<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xmlwrapp: XML Nodes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xmlwrapp
   </div>
   <div id="projectbrief">Lightweight C++ XML parsing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">index</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">XML Nodes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="node_types"></a>
Node Types</h1>
<p>As I mentioned earlier, almost everything in an XML document is a node. The first thing that you probably think of is the XML element, but XML elements are just one type of XML node.</p>
<p>Processing instructions, XML comments and even the whitespace around XML elements are nodes. When working with the <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> class, you are going to want to know what type of node you have. The <a class="el" href="classxml_1_1node.html#a6a52b1707c415f5ea488cffca48a03dd" title="Get this node&#39;s &quot;type&quot;. ">xml::node::get_type()</a> member function is what you should use.</p>
<p>The <a class="el" href="node_8h.html" title="This file contains the definition of the xml::node class. ">xmlwrapp/node.h</a> header file defines the node types as an enum. Using that enum and the <a class="el" href="classxml_1_1node.html#a6a52b1707c415f5ea488cffca48a03dd" title="Get this node&#39;s &quot;type&quot;. ">xml::node::get_type()</a> member function, you can discover what a node is holding.</p>
<h1><a class="anchor" id="node_name"></a>
The Node Name</h1>
<p>All xmlwrapp nodes have name data, but it might not be what you expect. The definition for a node's name is different for each type of node. For example, an element node's name is the tag name, but the name for a text node is a string constant, "text".</p>
<p>The <a class="el" href="classxml_1_1node.html#a1b9c2767b2b23bb5abb02e48aa643129" title="Get the name of this xml::node. ">xml::node::get_name()</a> function returns the name of the node. You probably guessed that <a class="el" href="classxml_1_1node.html#a02d75545214dba0cf6d7efeb5ecfa2bc" title="Set the name of this xml::node. ">xml::node::set_name()</a> will set the name of a node. The following table lists the most common node types and what they store in their name data.</p>
<table class="doxtable">
<tr>
<th>node type </th><th>get_name() return value  </th></tr>
<tr>
<td>element node (type_element) </td><td>the name of the tag, for example, "root" for "&lt;root/&gt;"  </td></tr>
<tr>
<td>text node (type_text) </td><td>the string constant "text"  </td></tr>
<tr>
<td>CDATA node (type_cdata) </td><td>NULL (zero) pointer  </td></tr>
<tr>
<td>processing instruction node (type_pi) </td><td>the processing instruction application name  </td></tr>
<tr>
<td>comment node (type_comment) </td><td>the string constant "comment"  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You should be prepared to handle the case where <a class="el" href="classxml_1_1node.html#a1b9c2767b2b23bb5abb02e48aa643129" title="Get the name of this xml::node. ">xml::node::get_name()</a> returns a NULL (zero) pointer.</dd></dl>
<h1><a class="anchor" id="node_contents"></a>
The Node Contents</h1>
<p>Very much like a node's name data, its contents vary depending on what type of node it is. For text nodes and CDATA nodes, the node's contents are the text data inside the node or CDATA block. The <a class="el" href="classxml_1_1node.html#a946b96b389eadbff34900e02dc8e2d0f" title="Get the content for this text node. ">xml::node::get_content()</a> function is used to get the node's content.</p>
<p>You should be aware of some magic that this function does. If you call it on an element node, which has no content by the way, it will try to return the content of its children text nodes, if it has any. An example should clarify things:</p>
<div class="fragment"><div class="line">&lt;list&gt;</div><div class="line">  &lt;entry&gt;Pick up a Sun Enterprise 10000 <span class="keywordflow">while</span> you are out shopping.&lt;/entry&gt;</div><div class="line">&lt;/list&gt;</div></div><!-- fragment --><p>Here, the <code>entry</code> node does not contain any contents because it is an element node. It does, however, contain a child node that is a text node. Calling the <a class="el" href="classxml_1_1node.html#a946b96b389eadbff34900e02dc8e2d0f" title="Get the content for this text node. ">xml::node::get_content()</a> function on that child text node should return "Pick
up a Sun Enterprise 10000 while you are out shopping.". What you might not expect is that calling the <a class="el" href="classxml_1_1node.html#a946b96b389eadbff34900e02dc8e2d0f" title="Get the content for this text node. ">xml::node::get_content()</a> function on the <code>entry</code> node returns the same string! Very cool if you ask me.</p>
<p>To be complete, here is a table that explains what the <a class="el" href="classxml_1_1node.html#a946b96b389eadbff34900e02dc8e2d0f" title="Get the content for this text node. ">xml::node::get_content()</a> function returns for the common node types:</p>
<table class="doxtable">
<tr>
<th>node type </th><th>get_content() return value  </th></tr>
<tr>
<td>element node (type_element) </td><td>the contents of its children nodes  </td></tr>
<tr>
<td>text node (type_text) </td><td>&lt;the text  </td></tr>
<tr>
<td>CDATA node (type_cdata) </td><td>the text inside the CDATA block  </td></tr>
<tr>
<td>processing instruction node (type_pi) </td><td>the processing instruction data  </td></tr>
<tr>
<td>comment node (type_comment) </td><td>the comment text  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You should be prepared to handle the case where the <a class="el" href="classxml_1_1node.html#a946b96b389eadbff34900e02dc8e2d0f" title="Get the content for this text node. ">xml::node::get_content()</a> function returns a NULL (zero) pointer.</dd></dl>
<p>The function for setting the node's content is <a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a" title="Set the content of a node. ">xml::node::set_content()</a>. This function performs the same magic that the get_content() function does. That is, if you call it on an element node, it will remove all of the node's children and replace them with a text node.</p>
<h1><a class="anchor" id="node_children"></a>
Accessing a Node's Children</h1>
<p>From what we have seen in the past few sections, XML nodes can have children. Almost all node types can have children. In order to make effective use of a node tree, you are going to want to access the children of a node. In xmlwrapp, this is done with iterators.</p>
<p>Using iterators you can walk the node tree, add nodes, remove nodes and even replace nodes. xmlwrapp iterators are just as useful as the standard library iterators, however please notice that all iterators provided by the library are only forward, and not random access or even bidirectional, i.e. they can only be used to iterate over a collection of nodes, but not to access arbitrary nodes directly nor iterate in the reverse direction.</p>
<h2><a class="anchor" id="node_children_begin"></a>
Begin and End Iterators</h2>
<p>Just like the standard containers, the <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> class has <a class="el" href="classxml_1_1node.html#a19f2858db5fed987227f80ff1c556b0b" title="Get an iterator that points to the beginning of this node&#39;s children. ">xml::node::begin()</a> and <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">xml::node::end()</a> member functions that return either a <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> or a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">xml::node::const_iterator</a>. They are very useful for working with the children of a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>, which are xml::nodes themselves.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> n;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">xml::node::iterator i(n.<a class="code" href="classxml_1_1node.html#a19f2858db5fed987227f80ff1c556b0b">begin</a>());</div><div class="line"><a class="code" href="classxml_1_1node_1_1iterator.html">xml::node::iterator</a> end(n.<a class="code" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552">end</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; i != end; ++i)</div><div class="line">{</div><div class="line">  <span class="comment">// do something with this child</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="node_children_find"></a>
Finding Children Nodes</h2>
<p>You can use the <a class="el" href="classxml_1_1node.html#a9c0e38e5095f0e682e00ea47d5d90a30" title="Find the first child node that has the given name. ">xml::node::find()</a> member function to find an element node by its name. There are four different version of the <a class="el" href="classxml_1_1node.html#a9c0e38e5095f0e682e00ea47d5d90a30" title="Find the first child node that has the given name. ">xml::node::find()</a> function. All of them return a <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> or a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">xml::node::const_iterator</a> that either points to the found element node, or is equal to the iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node. ">xml::node::end()</a> returns.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> n;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">xml::node::iterator i(n.<a class="code" href="classxml_1_1node.html#a9c0e38e5095f0e682e00ea47d5d90a30">find</a>(<span class="stringliteral">&quot;entry&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (i != n.<a class="code" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552">end</a>())</div><div class="line">{</div><div class="line">  <span class="comment">// do something with the found node</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="node_children_elements"></a>
Iterating Over Children Elements</h2>
<p>If you need to do something with all child element nodes, you can use <a class="el" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4" title="Returns view of child nodes of type type_element. ">xml::node::elements()</a> method to obtain a <em>view</em> of child nodes. The view, implemented by <a class="el" href="classxml_1_1nodes__view.html" title="This class implements a view of XML nodes. ">xml::nodes_view</a> and <a class="el" href="classxml_1_1const__nodes__view.html" title="This class implements a read-only view of XML nodes. ">xml::const_nodes_view</a> classes, behaves like a standard container in that it lets you iterate over the nodes in the usual way. The difference between the iterator returned by <a class="el" href="classxml_1_1nodes__view.html#af32c3cfbd820262b13f9c623238d8507" title="Get an iterator that points to the beginning of this view&#39;s nodes. ">xml::nodes_view::begin()</a> and the one from <a class="el" href="classxml_1_1node.html#a19f2858db5fed987227f80ff1c556b0b" title="Get an iterator that points to the beginning of this node&#39;s children. ">xml::node::begin()</a> is that the latter iterates over all child nodes, whereas the former iterates only over selected elements.</p>
<p>The usage is similar to iterating over all child nodes:</p>
<div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> n;</div><div class="line">...</div><div class="line">xml::nodes_view all(n.<a class="code" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a>());</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classxml_1_1nodes__view_1_1iterator.html">xml::nodes_view::iterator</a> i = all.begin()); i != all.<a class="code" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552">end</a>(); ++i)</div><div class="line">{</div><div class="line">  do_something_with_child(*i);</div><div class="line">}</div></div><!-- fragment --><p>Similarly, you can iterate over all child elements with given name using the <a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a" title="Returns view of child nodes of type type_element with name name. ">xml::node::elements(const char*)</a> method:</p>
<div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> n;</div><div class="line">...</div><div class="line">xml::nodes_view persons(n.<a class="code" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a>(<span class="stringliteral">&quot;person&quot;</span>));</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classxml_1_1nodes__view_1_1iterator.html">xml::nodes_view::iterator</a> i = all.begin()); i != all.<a class="code" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552">end</a>(); ++i)</div><div class="line">{</div><div class="line">  do_something_with_person_child(*i);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="node_add"></a>
Adding Children</h1>
<p>There are two ways of adding a child to a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. Which one you chose depends mostly on your style. The two member functions that allow you to do this are <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node. ">xml::node::push_back()</a> and <a class="el" href="classxml_1_1node.html#ade044c2b31477ea673e9839b3fb7cfcf" title="Insert a new child node. ">xml::node::insert()</a>.</p>
<h2><a class="anchor" id="node_add_pushback"></a>
Using push_back()</h2>
<p>The <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node. ">xml::node::push_back()</a> member function takes a const reference to a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a>. It will copy that node and then insert it as the last child.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> parent(<span class="stringliteral">&quot;parent&quot;</span>);</div><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> child(<span class="stringliteral">&quot;child&quot;</span>);</div><div class="line"></div><div class="line">parent.push_back(child);</div></div><!-- fragment --><p>The <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node. ">xml::node::push_back()</a> function is just like the push_back() function for the standard library containers. You should be aware that it inserts a copy of the given node, and not the node itself.</p>
<p>In the example above, if you modified the <code>child</code> node after it was inserted into the <code>parent</code> node, those modifications will not be reflected in the <code>parent</code> node's copy of <code>child</code>.</p>
<p>See the next section for a better way of adding child nodes when you want to modify them after adding them to another node.</p>
<h2><a class="anchor" id="node_add_insert"></a>
Using insert</h2>
<p>The <a class="el" href="classxml_1_1node.html#ade044c2b31477ea673e9839b3fb7cfcf" title="Insert a new child node. ">xml::node::insert()</a> function is a lot more flexible compared to the <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node. ">xml::node::push_back()</a> function. For starters, you can insert a node anywhere in the list of children. This means you can add the node to the back or even the front of the child list.</p>
<p>More importantly, <a class="el" href="classxml_1_1node.html#ade044c2b31477ea673e9839b3fb7cfcf" title="Insert a new child node. ">xml::node::insert()</a> returns a <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> that points to the copy of the node that was inserted. This means that you can modify the new child after it has been inserted into the parent.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> parent(<span class="stringliteral">&quot;parent&quot;</span>);</div><div class="line"><a class="code" href="classxml_1_1node.html">xml::node</a> child(<span class="stringliteral">&quot;child&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classxml_1_1node_1_1iterator.html">xml::node::iterator</a> i(parent.insert(parent.begin(), child);</div><div class="line"></div><div class="line">i-&gt;set_name(<span class="stringliteral">&quot;kid&quot;</span>);</div></div><!-- fragment --><h1><a class="anchor" id="node_remove"></a>
Removing and Replacing Children</h1>
<p>Using iterators, it is possible to remove children and to replace them with other nodes. To remove a child node, you first need a <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> that points to it, then you can call <a class="el" href="classxml_1_1node.html#af37a72ed93f838c58057c3865d21ff4f" title="Erase the node that is pointed to by the given iterator. ">xml::node::erase()</a>.</p>
<p>The <a class="el" href="classxml_1_1node.html#af37a72ed93f838c58057c3865d21ff4f" title="Erase the node that is pointed to by the given iterator. ">xml::node::erase()</a> function will return a <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container...">xml::node::iterator</a> that points to the node after the one being removed. This should help you if you are iterating over all the children and wanted to remove one without losing your place.</p>
<p>To replace a node for which you have an iterator, you can use the <a class="el" href="classxml_1_1node.html#a08f5714a2eae4aa9ec6846476bf78414" title="Replace the node pointed to by the given iterator with another node. ">xml::node::replace()</a> function. It will remove and clean up the old node, and insert the new node in its place.</p>
<h1><a class="anchor" id="node_attr"></a>
Accessing Node Attributes</h1>
<p>In addition to possibly having children, an element node may have attributes. In xmlwrapp, these attributes are stored in a <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node. ">xml::attributes</a> class. You can use the <a class="el" href="classxml_1_1node.html#adfc02a04956784efa60a740a165b464b" title="Get the list of attributes. ">xml::node::get_attributes()</a> function to get a reference to a node's <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node. ">xml::attributes</a> object. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 8 2018 17:13:50 for xmlwrapp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
